Saisie et Encodage de la Requête par le Client :

L’utilisateur saisit une commande au format « get Nom_du_fichier ».
Le client analyse cette commande pour extraire le nom du fichier.
Il remplit une structure request_t (dont le champ filename a une taille fixe définie par MAX_FILENAME_LEN) avec le type de requête (GET) et le nom du fichier.
Le client envoie la structure complète via la socket en utilisant une fonction comme Rio_writen, garantissant ainsi que le serveur reçoit exactement sizeof(request_t) octets.
Établissement de la Connexion et Réception de la Requête par le Serveur :
Le serveur attend les connexions sur son port d’écoute (ici 2121) en utilisant Open_listenfd et Accept.
Une fois la connexion acceptée, le serveur lit exactement sizeof(request_t) octets à l’aide de Rio_readn.
Le serveur extrait alors le nom du fichier contenu dans la structure, sachant précisément combien d’octets il doit lire pour ce champ.

Traitement de la Requête sur le Serveur :
Le serveur construit le chemin complet du fichier en préfixant le nom par le répertoire de travail (par exemple, "./server/").
Il tente d’ouvrir le fichier en lecture.
Si l’ouverture échoue (fichier non trouvé, permissions, etc.), il prépare une réponse d’erreur dans une structure response_t (par exemple, avec un code ERR_FILE_NOT_FOUND).
Si l’ouverture réussit, il utilise fstat pour déterminer la taille du fichier.
Le serveur charge le fichier entier en mémoire (en une seule opération) afin de pouvoir ensuite l’envoyer.

Préparation et Envoi de la Réponse par le Serveur :
Le serveur prépare une structure response_t comportant :
Un champ code indiquant le succès (SUCCESS) ou l’erreur.
Un champ filesize indiquant la taille du fichier (valide en cas de succès).
Le serveur envoie d’abord cette structure via Rio_writen pour informer le client du résultat.
En cas de succès, le serveur envoie ensuite le contenu du fichier (en mode binaire) sur la même connexion.
Réception de la Réponse et des Données par le Client :
Le client reçoit la structure response_t pour connaître le résultat de la requête.
Si le code indique une erreur, le client affiche un message d’erreur pertinent.
Si le code indique un succès, le client sait exactement combien d’octets il doit lire (grâce à filesize).
Le client lit alors le contenu du fichier, en s’assurant de lire exactement le nombre d’octets indiqué.

Sauvegarde du Fichier et Affichage des Statistiques côté Client :
Le client construit le chemin complet du fichier de destination en préfixant le nom par le répertoire "./client/" et sauvegarde le fichier dans ce dossier.
Pendant le transfert, le client peut mesurer le temps écoulé (par exemple avec gettimeofday) pour calculer le débit de transfert.
Une fois le transfert terminé, il affiche un message du type :
bash
Copy
Transfer successfully complete.
X bytes received in Y seconds (Z Kbytes/s).
indiquant le nombre d’octets reçus, le temps de transfert et le débit calculé.

Clôture de la Connexion :
Une fois le transfert terminé et le fichier sauvegardé, le client ferme la connexion.
Le serveur ferme également la connexion pour ce client et revient en attente de nouvelles connexions.